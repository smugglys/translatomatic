require 'fileutils'

RSpec.shared_examples "a resource file" do |config|
  include Helpers

  TEST_LOCALE_LIST ||= [
    "de",
    "de-DE",
    "en-US",
    "zh-Hans"
  ]

  def self.test_file
    ext = described_class.extensions.first
    "test.#{ext}"
  end

  (config[:test_files] || [test_file]).each do |fixture|
    it "loads #{fixture}" do
      file = load_test_file(fixture)
      expect(file).to be
      expected_properties = config[:load_properties] || {
        "property1" => "value 1",
        "property2" => "value 2",
      }
      expected_properties = expected_properties.transform_keys do |i|
        i.sub(/property/, 'key')
      end if config[:autogenerated_keys]

      expect(file.properties).to eq(expected_properties)
    end
  end

  it "creates a new #{described_class.to_s.demodulize} file" do
    file = described_class.new
    expect(file).to be
  end

=begin
  # skip resource file types that will accept any kind of input
  unless described_class == Translatomatic::ResourceFile::Text ||
    described_class == Translatomatic::ResourceFile::Markdown ||
    described_class == Translatomatic::ResourceFile::HTML

    it "raises an exception when the existing content cannot be parsed" do
      ext = described_class.extensions.first
      fixture = ext == "properties" ? "test.html" : "test.properties"
      expect {
        described_class.load(fixture_path(fixture))
      }.to raise_error
    end
  end
=end

  it "saves a file" do
    file = load_test_file

    ext = described_class.extensions.first
    save_path = create_tempfile("test.#{ext}")
    properties = config[:save_properties] || {
      "property1" => "saved value 1",
      "property2" => "saved value 2",
    }
    properties = properties.transform_keys {
      |i| i.sub(/property/, 'key') } if config[:autogenerated_keys]

    file.properties = properties
    file.save(save_path, no_created_by: true)
    expected_result = fixture_read("test_save.#{ext}")
    actual_result = save_path.read

    if RUBY_PLATFORM == "java" &&
      described_class <= Translatomatic::ResourceFile::XML
      # ignore whitespace in xml output
      actual_result = remove_xml_whitespace(actual_result)
      expected_result = remove_xml_whitespace(expected_result)
    end

    expect(actual_result).to eql(expected_result)
  end

  it "adds created by comment" do
    # exercise add created by code
    file = load_test_file
    ext = described_class.extensions.first
    save_path = create_tempfile("test.#{ext}")
    file.save(save_path)
  end

  config[:locale_path_conversions].each do |conversion|
    TEST_LOCALE_LIST.each do |source_locale|
      TEST_LOCALE_LIST.each do |target_locale|
        described_class.extensions.each do |ext|
          source = conversion.source(ext, source_locale)
          target = conversion.target(ext, target_locale)
          it "changes filename '#{source}' to '#{target}'" do
            file = described_class.new(source)
            expect(file.locale_path(target_locale).to_s).to eq(target)
          end
        end
      end
    end
  end

  config[:locale_path_conversions].each do |conversion|
    TEST_LOCALE_LIST.each do |locale|
      described_class.extensions.each do |ext|
        path = conversion.target(ext, locale)
        it "detects locale '#{locale}' from '#{path}'" do
          file = described_class.new(path)
          expect(file.locale.to_s).to eq(locale)
        end
      end
    end
  end

  private

  def load_test_file(fixture = nil)
    fixture ||= self.class.test_file
    path = File.join("resource_file", fixture)
    contents = fixture_read(path)  # converts crlf to lf
    path = create_tempfile(fixture, contents)
    described_class.new(path)
  end
end  # end shared examples

class PathConversion

  def initialize(from, to)
    @source = from
    @target = to
  end

  def source(ext, locale)
    subst(@source, ext, locale)
  end

  def target(ext, locale)
    subst(@target, ext, locale)
  end

  private

  def subst(string, ext, locale)
    string.sub("$EXT", ext).sub("$LOC", locale)
  end
end
