require 'fileutils'

RSpec.shared_examples 'a resource file' do |config = {}|
  include Helpers

  class PathUtilsTest
    class << self
      include Translatomatic::PathUtils
    end
  end

  TEST_LOCALE_LIST ||= [
    'de',
    'de-DE',
    'en-US',
    'zh-Hans'
  ].freeze

  PATH_CONVERSIONS ||= [
    # locale after _ in basename
    PathConversion.new('path/file.$EXT', 
      "path/file#{described_class.preferred_locale_separator}$LOC.$EXT"),
    PathConversion.new('path/file_$LOC.$EXT', 'path/file_$LOC.$EXT'),
    # locale in extension list
    PathConversion.new('path/file.$EXT.$LOC', 'path/file.$EXT.$LOC'),
    PathConversion.new('path/file.$LOC.$EXT', 'path/file.$LOC.$EXT'),
    # xcode localised files
    PathConversion.new('$LOC.lproj/file.$EXT', '$LOC.lproj/file.$EXT'),
    PathConversion.new('Base.lproj/file.$EXT', '$LOC.lproj/file.$EXT'),
    # locale in parent directory name
    PathConversion.new('$LOC/file.$EXT', '$LOC/file.$EXT'),
    # locale in values- path (android)
    PathConversion.new('res/values/file.$EXT', 'res/values-$LOC/file.$EXT'),
    PathConversion.new('res/values-$LOC/file.$EXT', 'res/values-$LOC/file.$EXT'),
    # file basename is locale
    PathConversion.new('config/locales/$LOC.$EXT', 'config/locales/$LOC.$EXT'),
    PathConversion.new('config/locales/test/$LOC.$EXT', 'config/locales/test/$LOC.$EXT')
  ].freeze

  def self.test_file(ext = nil)
    ext ||= described_class.extensions.first
    "test.#{ext}"
  end

  def self.context_test_file(ext)
    context_path = File.join('translation_context', test_file(ext))
    fixture_path(context_path, allow_missing: true)
  end

  def new_file(path = nil, options = {})
    described_class.new(path, options)
  end

  (config[:test_files] || [test_file]).each do |fixture|
    it "loads #{fixture}" do
      file = load_test_file(fixture)
      expect(file).to be
      expected_properties = config[:load_properties] || {
        'property1' => 'value 1',
        'property2' => 'value 2'
      }
      if config[:autogenerated_keys]
        expected_properties = expected_properties.transform_keys do |i|
          i.sub(/property/, 'key')
        end
      end

      expect(file.properties).to eq(expected_properties)
    end
  end

  context '#new' do
    it "creates a new #{described_class.to_s.demodulize} file" do
      file = new_file
      expect(file).to be
    end
  end

  context '#save' do
    it 'adds properties to an empty file' do
      properties = {
        'property1' => 'value 1',
        'property2' => 'value 2'
      }
      file = new_file
      file.properties = properties

      ext = described_class.extensions.first
      save_path = create_tempfile("test.#{ext}")
      file.save(save_path)
      file = new_file(save_path)
      expect(file.properties).to be_present
      expect(file.properties).to eq(properties) if described_class.key_value?
    end

    it 'adds a blank property' do
      properties = { 'property1' => nil }
      file = new_file
      file.properties = properties
      ext = described_class.extensions.first
      save_path = create_tempfile("test.#{ext}")
      file.save(save_path)
      file = new_file(save_path)
      expect(file.get('property1')).to be_blank
    end
  end

  if described_class.supports_variable_interpolation?
    it 'creates variables' do
      file = described_class.new
      variable = file.create_variable('test')
      expect(variable).to be
    end

    it 'has a regex to match variables' do
      file = described_class.new
      expect(file.variable_regex).to be
    end
  else
    it 'does not create variables' do
      file = described_class.new
      variable = file.create_variable('test')
      expect(variable).to be_nil
    end

    it 'does not have a regex to match variables' do
      file = described_class.new
      expect(file.variable_regex).to be_nil
    end
  end

  # extension specific tests
  described_class.extensions.each do |ext|
    context "extension #{ext}" do
      if fixture_path(test_file(ext), allow_missing: true)
        it 'saves a file' do
          source_file = load_test_ext(ext)
          properties = config[:save_properties] || {
            'property1' => 'saved value 1',
            'property2' => 'saved value 2'
          }
          if config[:autogenerated_keys]
            properties = properties.transform_keys { |i| i.sub(/property/, 'key') }
          end
          source_file.properties = properties
          test_save(source_file, fixture_read("test_save.#{ext}"), ext)
        end

        it 'adds created by comment' do
          # exercise add created by code
          file = load_test_ext(ext)
          save_path = create_tempfile("test.#{ext}")
          file.save(save_path)
        end
      end

      # test context parsing
      if !config[:skip_context_test] && context_file = context_test_file(ext)
        it 'associates keys with contexts' do
          options = config[:context_options] || {}
          file = described_class.new(context_file, options)
          expect(file.properties).to be_present
          file.properties.each_key do |key|
            expect(file.get_context(key)).to be
          end
        end
      end

      PATH_CONVERSIONS.each do |conversion|
        TEST_LOCALE_LIST.each do |source_locale|
          TEST_LOCALE_LIST.each do |target_locale|
            source = conversion.source(ext, source_locale)
            target = conversion.target(ext, target_locale)
            next if source == target
            it "changes filename '#{source}' to '#{target}'" do
              result = PathUtilsTest.modify_path_locale(source, target_locale)
              expect(result.to_s).to eq(target.to_s)
            end
          end
        end
      end

      PATH_CONVERSIONS.each do |conversion|
        TEST_LOCALE_LIST.each do |locale|
          path = conversion.target(ext, locale)
          it "detects locale '#{locale}' from '#{path}'" do
            detected_locale = PathUtilsTest.detect_path_locale(path)
            expect(detected_locale.to_s).to eq(locale)
          end
        end
      end
    end
    # end extension block
  end

  private

  def test_save(source_file, expected_result, ext = nil)
    ext ||= described_class.extensions.first
    save_path = create_tempfile("test.#{ext}")
    source_file.save(save_path, no_created_by: true)
    actual_result = save_path.read

    if RUBY_PLATFORM == 'java' &&
       described_class <= Translatomatic::ResourceFile::XML
      # ignore whitespace in xml output
      actual_result = remove_xml_whitespace(actual_result)
      expected_result = remove_xml_whitespace(expected_result)
    end

    expect(actual_result).to eql(expected_result)
  end

  def load_test_ext(ext)
    fixture = self.class.test_file(ext)
    described_class.new(fixture_path(fixture))
  end

  def load_test_file(fixture, options = {})
    described_class.new(fixture_path(fixture), options)
  end
end

class PathConversion
  def initialize(from, to)
    @source = from
    @target = to
  end

  def source(ext, locale)
    Pathname.new(subst(@source, ext, locale))
  end

  def target(ext, locale)
    Pathname.new(subst(@target, ext, locale))
  end

  private

  def subst(string, ext, locale)
    string.sub('$EXT', ext).sub('$LOC', locale)
  end
end
